/*
 * receive bisync data and write received data to a file
 *
 * This sample demonstrates bisync communications using a
 * SyncLink serial card. The companion sample send-bisync.c sends
 * bisync data. Use both programs to send data between two serial cards
 * connected with a NULL modem (cross over cable) or other serial link.
 *
 * The sample is simple to clearly show basic programming concepts.
 * Use this code to start development of more complex applications.
 *
 * Overview:
 *
 * 1. open serial device (syscall open)
 * 2. configure serial device (syscall ioctl)
 * 3. receive data from serial device (syscall read)
 * 4. write received data to a file
 *
 * For more information about SyncLink specific programming refer to
 * the Programming.txt file included with the SyncLink software package.
 *
 * Microgate and SyncLink are registered trademarks
 * of Microgate corporation.
 *
 * This code is released under the GNU General Public License (GPL)
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <stdio.h>
#include <memory.h>
#include <signal.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/ioctl.h>
#include <linux/types.h>
#include <termios.h>
#include <errno.h>

#include "synclink.h"

#ifndef N_HDLC
#define N_HDLC 13
#endif

/*
 * set base clock frequency in cycles per second
 *
 * Data clocks are generated by dividing a fixed base clock by a 16-bit integer.
 * GT family base clock default is 14.7456MHz.
 *
 * Other base clocks (up to 33MHz) can be installed
 * at the factory by special order. Non default values require driver
 * configuration with the actual value so correct divisors are used for
 * a specified data rate.
 */
int set_base_clock(int fd, unsigned int freq)
{
	MGSL_PARAMS params;
	int rc;

	/* fields other than mode and clock_speed are ignored */
	params.mode = MGSL_MODE_BASE_CLOCK;
	params.clock_speed = freq;
	rc = ioctl(fd, MGSL_IOCSPARAMS, &params);
	if (rc < 0) {
		printf("set base clock frequency error=%d %s\n",
		       errno, strerror(errno));
	}
	return rc;
}

/* handle SIGINT - do nothing */
void sigint_handler(int sigid){}

/*
 * wait for and process one block of received data
 *
 * A block is defined by a start of block (sob) character
 * and an end of block (eob) character.
 *
 * The start of block and end of block characters are only examples.
 * Actual application definition of block boundaries will be different.
 *
 * arguments:
 *
 * fd   open file descriptor to serial device
 * fp   open file pointer to output file
 *
 * returns:
 *
 * 0 = success, otherwise error
 */
int get_received_block(int fd, FILE *fp)
{
	int rc;
	int i;
	unsigned char buf[4096];       /* buffer for individual read calls */
	unsigned char block_buf[4096]; /* assembled data block */
	int count = 0; /* count of bytes in block_buf */
	int sob = 0;   /* start of block flag */
	int eob = 0;   /* end of block flag */
	unsigned char sob_char = 0x55;
	unsigned char eob_char = 0xaa;

	while (!eob) {

		/* get data from serial port */
		rc = read(fd, buf, sizeof(buf));
		if (rc < 0) {
			printf("read() error=%d %s\n", errno, strerror(errno));
			return rc;
		}
		printf("received %d bytes\n", rc);

		if (!sob) {
			/* search for start of block */
			for (i=0 ; i < rc ; i++) {
				if (buf[i] == sob_char) {
					printf("start of block found\n");
					sob = 1;
					rc -= i;
					memmove(buf, buf+i, rc);
					break;
				}
			}
		}

		if (rc == 0)
			continue;

		/* search for end of block */
		for (i=0 ; i < rc ; i++) {
			if (buf[i] == eob_char) {
				printf("end of block found\n");
				rc = i + 1;
				eob = 1;
				break;
			}
		}

		if ((count + rc) > sizeof(block_buf)) {
			printf("end of block not found and buffer full\n");
			return -1;
		}

		memcpy(&block_buf[count], buf, rc);
		count += rc;

	}

	/*
	 * disable and then enable receiver to discard any remaining
	 * bytes in receive buffers (usually trailing 0xff or noise bytes
	 * following the block) and to force the receiver back into
	 * 'hunt mode' where it searches for the next incoming sync pattern.
	 */
	ioctl(fd, MGSL_IOCRXENABLE, 0);
	ioctl(fd, MGSL_IOCRXENABLE, 1);

	/* save received block to file */
	printf("block received size=%d\n", count);
	rc = fwrite(block_buf, sizeof(char), count, fp);
	if (count != rc) {
		printf("fwrite error=%d %s\n", errno, strerror(errno));
		return rc;
	}
	fflush(fp);

	return 0;
}

int main(int argc, char* argv[])
{
	int fd;
	int rc;
	int ldisc = N_HDLC;
	MGSL_PARAMS params;
	int sigs, idle;
	FILE *fp = NULL;
	char *devname;
	unsigned char syn1, syn2;

	if (argc > 1)
		devname = argv[1];
	else
		devname = "/dev/ttySLG0";

	printf("receive bisync data on %s\n", devname);

	/* open file to save received data */
	fp = fopen("data", "wb");
	if (fp == NULL) {
		printf("fopen error=%d %s\n", errno, strerror(errno));
		return errno;
	}

	/* open serial device with O_NONBLOCK to ignore DCD */
	fd = open(devname, O_RDWR | O_NONBLOCK, 0);
	if (fd < 0) {
		printf("open error=%d %s\n", errno, strerror(errno));
		return errno;
	}

	/* set N_HDLC line discipline (use for protocols other than async) */
	rc = ioctl(fd, TIOCSETD, &ldisc);
	if(rc < 0) {
		printf("set line discipline error=%d %s\n",
		       errno, strerror(errno));
		return rc;
	}

	/* required only if custom base clock (not 14745600) installed */
//	if (set_base_clock(fd, 32000000) < 0)
//		return rc;

	/* get current device parameters */
	rc = ioctl(fd, MGSL_IOCGPARAMS, &params);
	if (rc < 0) {
		printf("ioctl(MGSL_IOCGPARAMS) error=%d %s\n",
		       errno, strerror(errno));
		return rc;
	}

	/*
	 * modify device parameters
	 *
	 * bisync mode, loopback disabled, NRZ encoding
	 * data clocks sourced from clock input pins
	 * generate 9600 bps clock on auxclk output pin
	 * hardware CRC is not supported for bisync
	 *
	 * Parity generation/checking or CRC generation/checking
	 * must be performed by application if needed.
	 */

	params.mode = MGSL_MODE_BISYNC;
	params.loopback = 0;
	params.flags = HDLC_FLAG_RXC_RXCPIN + HDLC_FLAG_TXC_TXCPIN;
	params.encoding = HDLC_ENCODING_NRZ;
	params.clock_speed = 9600;
	params.crc_type = HDLC_CRC_NONE;

	/* set current device parameters */
	rc = ioctl(fd, MGSL_IOCSPARAMS, &params);
	if (rc < 0) {
		printf("ioctl(MGSL_IOCSPARAMS) error=%d %s\n",
		       errno, strerror(errno));
		return rc;
	}

	/*
         * set SYN1 and SYN2 sync characters
	 *
	 * These are example values only. The actual value needed for
	 * a specific application will be different.
	 */

	syn1 = 0x67;
	syn2 = 0x98;
	idle = HDLC_TXIDLE_CUSTOM_16 | (syn2 << 8) | syn1;
	rc = ioctl(fd, MGSL_IOCSTXIDLE, idle);
	if (rc < 0) {
		printf("ioctl(MGSL_IOCSTXIDLE) error=%d %s\n",
		       errno, strerror(errno));
		return rc;
	}

	printf("Turn on RTS and DTR serial outputs\n");
	sigs = TIOCM_RTS + TIOCM_DTR;
	rc = ioctl(fd, TIOCMBIS, &sigs);
	if(rc < 0) {
		printf("assert DTR/RTS error=%d %s\n",
		       errno, strerror(errno));
		return rc;
	}

	/* set device to blocking mode for reads and writes */
	fcntl(fd, F_SETFL, fcntl(fd,F_GETFL) & ~O_NONBLOCK);

	/* set ctrl-C to interrupt syscall but not exit program */
	printf("Press Ctrl-C to stop program.\n");
	signal(SIGINT, sigint_handler);
	siginterrupt(SIGINT, 1);


	/*
	 * disable and then enable receiver to discard any stale
	 * bytes in receive buffers and to force receiver into
	 * 'hunt mode' where it searches for the next incoming sync pattern.
	 */
	ioctl(fd, MGSL_IOCRXENABLE, 0);
	ioctl(fd, MGSL_IOCRXENABLE, 1);

	/*
	 * read() returns data when a driver receive buffer (256 bytes) fills.
	 * At low data rates this may cause too much delay between receipt of
	 * a byte and that byte being returned to the application.
	 *
	 * Bits 31..16 of the MGSL_IOCRXENABLE ioctl argument specify
	 * the receive buffer fill level. When the specified
	 * number of bytes are received, read() returns the data. The value
	 * also controls the data transfer mode used by hardware (PIO or DMA).
	 *
	 * 128 to 256: DMA mode, value MUST be a multiple of 4
	 * 1   to 127: PIO mode, any value in this range is valid
	 * 0         : No operation - do not alter the fill level
	 *
	 * Use lower values as needed for lower data rates and lower latency.
	 * At high data rates PIO mode may cause data loss.
	 *
	 * Uncomment the line below to set the fill level to 8 bytes
	 * and select PIO mode.
	 */
//	ioctl(fd, MGSL_IOCRXENABLE, ((8 << 16) | 1));

	/* process received blocks until error or ctrl-C */

	rc = 0;
	while (!rc) {
		rc = get_received_block(fd, fp);
	}

	printf("Turn off RTS and DTR serial outputs\n");
	sigs = TIOCM_RTS + TIOCM_DTR;
	rc = ioctl(fd, TIOCMBIC, &sigs);
	if (rc < 0) {
		printf("negate DTR/RTS error=%d %s\n",
		       errno, strerror(errno));
		return rc;
	}

	close(fd);
	fclose(fp);

	return 0;
}


